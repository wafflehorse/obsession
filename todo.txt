[x] Update RenderQuad struct to remove Rect
[x] Add basic tilemap
[x] Create a base resolution in the game and allow for window resizing that scales quads to the right resolution
[x] Figure out how pixels_per_units actually scales things up and down as screen size changes
	- right now we set the camera size once based on pixels per unit, but we don't update it. We also only set the projection matrix once.
	- So how is tilemap scaling up?
	- And what's interesting, is our ui gets updated with the new pixels per unit each frame and the text seems to stay the same size
	- Revelation: Projection matrix maps our world coordinates to the ndc coords [-1, 1], the viewport stretches those coords to our screen size. 
		- what this means, we set projection and camera once. Then, our internal world units will always scale up correctly with the screen size increasing as long as we update the viewport. 
		- So, we currently have an issue because we update pixels per unit every frame based on the viewport (based on the screen size), but really, the game should never be thinking about pixels per unit really. It should be used to set the camera size, which sets the projection matrix and then scaling happens automatically by the viewport. 

[x] Remove pixels per unit from ui.cpp (viewport should handle the scaling)
	- Although, with fonts, we might be able to cheat a bit and use smaller fonts than our simulated resolution?
[x] Remove screen_size from camera size. Camera size should be based on base resolution
[x] bash script to output pngs from aseprite file
[x] implment bitmap packer with stb_rect_pack
[x] Add bitmap trimming to packer
[x] Add token split function to waffle_lib.h
[x] Add w_to_uppercase function
[x] Add sort algorithm (just ended up using qsort)
[x] Maybe rename the ase_packer tool as its contains the following tools
	- Aseprite export bash script
	- bitmap packer
	- will eventually construct sprite and animations into a header file
[x] Finish up Asepacker tool
[x] Update w_str_length to w_str_len
[x] Figure out how to manage aseprite file with sprite atlas in it
	- Need to somehow label and extract individual bmps
	- Just using slices and a separate aseprite cli call
[x] import basic tileset from stranded
[x] Render basic tileset
[x] Create player entity w/ animation
[x] Add player input
[x] Add player movement
[x] Handle movement animations
[x] Fix player idle flip handling
[x] Fix typing issues around sprite id and animation id
    - Had to separate sprite_assets.h into asset_ids.h and asset_tables.h
[x] Add gamepad support
[x] Get LSP working for gd and autocorrect
[x] Get entity management working, lookups, ids, etc.
	- What if we free an entity in the entity loop, which causes us to move the last entity to that position,
	which would mean that entity would not get updated?
		- What if we instead had the loop operate on ids? Would that change anything?
[x] Add z_indexing to render groups and entities
[x] Add gun entity with sprite
[x] Update gun z_index based on player (when facing up, gun should render under player)
[x] Updating window settings to not always be on top and to take mouse input focus
[x] Updates player facing direction to be dictated by aim vector
[x] Add gun sounds
[x] Add bullet sprite
[x] Adds projectile entity
[x] Adds player shooting
[x] Adds projectile distance traveled based deletion
[x] Adds screen shake
[x] Fixes bug in player aim vector (it was relative to camera rather than player)
[x] Add warrior entity
[x] Add a 1 pixel gap between packed sprites. Sprites sometimes have bleed where you can see the edge of the neighboring sprite
[x] Add projectile collision with warrior
[x] Add entity collider
[x] Add entity collider debug rendering
[] Add projectile <> warrior collision response
[] Add warrior health
[] Add player health


[] Add pathfinding to player when in range
[] Add warrior attacks
[] Add warrior attack collision with player
[] Move sounds out of GameState and into it's own sound table where we can allocate with arena based on num variations per sound and stuff.

